//go:build go1.22

// Package webserver provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package webserver

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
)

// Defines values for ArrAppFindingMediaType.
const (
	Film   ArrAppFindingMediaType = "film"
	Series ArrAppFindingMediaType = "series"
)

// Defines values for RetrieverCategory.
const (
	RetrieverCategoryArrApp        RetrieverCategory = "arr_app"
	RetrieverCategoryFolder        RetrieverCategory = "folder"
	RetrieverCategoryTorrentClient RetrieverCategory = "torrent_client"
)

// Defines values for RetrieverSoftwareName.
const (
	RetrieverSoftwareNameDeluge   RetrieverSoftwareName = "deluge"
	RetrieverSoftwareNameFolder   RetrieverSoftwareName = "folder"
	RetrieverSoftwareNameRadarr   RetrieverSoftwareName = "radarr"
	RetrieverSoftwareNameRtorrent RetrieverSoftwareName = "rtorrent"
	RetrieverSoftwareNameSonarr   RetrieverSoftwareName = "sonarr"
)

// Defines values for GetEntryMappingsParamsFilter.
const (
	CompleteEntries   GetEntryMappingsParamsFilter = "complete_entries"
	IncompleteEntries GetEntryMappingsParamsFilter = "incomplete_entries"
)

// ArrAppFinding defines model for ArrAppFinding.
type ArrAppFinding struct {
	// MediaFilePath The file path the media entry is located at.
	MediaFilePath *string `json:"mediaFilePath,omitempty"`

	// MediaType The media type of this entry.
	MediaType *ArrAppFindingMediaType `json:"mediaType,omitempty"`

	// Monitored Indicates whether the entry is monitored.
	Monitored *bool `json:"monitored,omitempty"`

	// ParentName The name of the parent.
	ParentName *string `json:"parentName,omitempty"`
}

// ArrAppFindingMediaType The media type of this entry.
type ArrAppFindingMediaType string

// EntryMapping defines model for EntryMapping.
type EntryMapping struct {
	// Name The name of this entry.
	Name              *string                               `json:"name,omitempty"`
	RetrieverFindings *[]EntryMappingRetrieverFindingsInner `json:"retrieverFindings,omitempty"`
}

// EntryMappingRetrieverFindingsInner defines model for EntryMapping_retrieverFindings_inner.
type EntryMappingRetrieverFindingsInner struct {
	Detail *EntryMappingRetrieverFindingsInnerDetail `json:"detail,omitempty"`

	// Id Id used to identify retrievers.
	Id *RetrieverId `json:"id,omitempty"`
}

// EntryMappingRetrieverFindingsInnerDetail defines model for EntryMapping_retrieverFindings_inner_detail.
type EntryMappingRetrieverFindingsInnerDetail struct {
	union json.RawMessage
}

// ErrorResponseBody defines model for ErrorResponseBody.
type ErrorResponseBody struct {
	Detail string `json:"detail"`
	Error  string `json:"error"`
}

// FolderFinding defines model for FolderFinding.
type FolderFinding struct {
	// FilePath The path of the file.
	FilePath *string `json:"filePath,omitempty"`

	// Size The file size in bytes.
	Size *int64 `json:"size,omitempty"`
}

// Retriever defines model for Retriever.
type Retriever struct {
	// Category The category this retriever belongs to.
	Category RetrieverCategory `json:"category"`

	// Id Id used to identify retrievers.
	Id RetrieverId `json:"id"`

	// Name The provided name used to differentiate between multiple instances of the same software retrievers.
	Name string `json:"name"`

	// SoftwareName The name of the retriever's software.
	SoftwareName RetrieverSoftwareName `json:"softwareName"`
}

// RetrieverCategory The category this retriever belongs to.
type RetrieverCategory string

// RetrieverSoftwareName The name of the retriever's software.
type RetrieverSoftwareName string

// RetrieverId Id used to identify retrievers.
type RetrieverId = string

// TorrentClientFinding defines model for TorrentClientFinding.
type TorrentClientFinding struct {
	// ClientName The name of the torrent client software.
	ClientName *string `json:"clientName,omitempty"`

	// DownloadFilePath The file path the download is located at.
	DownloadFilePath *string `json:"downloadFilePath,omitempty"`

	// DownloadedAt The date the torrent got downloaded at.
	DownloadedAt *time.Time `json:"downloadedAt,omitempty"`
	Ratio        *float32   `json:"ratio,omitempty"`

	// Size The file size in bytes.
	Size *int64 `json:"size,omitempty"`

	// TorrentName The name of the torrent.
	TorrentName *string `json:"torrentName,omitempty"`

	// TrackerHost The hostname of the tracker used by the torrent.
	TrackerHost *string `json:"trackerHost,omitempty"`
}

// GetEntryMappings200Response defines model for getEntryMappings_200_response.
type GetEntryMappings200Response struct {
	Entries []EntryMapping `json:"entries"`

	// TotalAmount The total amount of entries that could be returned for the provided filter.
	TotalAmount int `json:"totalAmount"`
}

// GetRetrievers200Response defines model for getRetrievers_200_response.
type GetRetrievers200Response struct {
	Retrievers []Retriever `json:"retrievers"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse = ErrorResponseBody

// GetEntryMappingsParams defines parameters for GetEntryMappings.
type GetEntryMappingsParams struct {
	// Page The page number to display.
	Page int `form:"page" json:"page"`

	// PageSize The amount of items to display per each page.
	PageSize int `form:"pageSize" json:"pageSize"`

	// Filter The filter to apply before returning the entries.
	Filter *GetEntryMappingsParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetEntryMappingsParamsFilter defines parameters for GetEntryMappings.
type GetEntryMappingsParamsFilter string

// AsTorrentClientFinding returns the union data inside the EntryMappingRetrieverFindingsInnerDetail as a TorrentClientFinding
func (t EntryMappingRetrieverFindingsInnerDetail) AsTorrentClientFinding() (TorrentClientFinding, error) {
	var body TorrentClientFinding
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTorrentClientFinding overwrites any union data inside the EntryMappingRetrieverFindingsInnerDetail as the provided TorrentClientFinding
func (t *EntryMappingRetrieverFindingsInnerDetail) FromTorrentClientFinding(v TorrentClientFinding) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTorrentClientFinding performs a merge with any union data inside the EntryMappingRetrieverFindingsInnerDetail, using the provided TorrentClientFinding
func (t *EntryMappingRetrieverFindingsInnerDetail) MergeTorrentClientFinding(v TorrentClientFinding) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArrAppFinding returns the union data inside the EntryMappingRetrieverFindingsInnerDetail as a ArrAppFinding
func (t EntryMappingRetrieverFindingsInnerDetail) AsArrAppFinding() (ArrAppFinding, error) {
	var body ArrAppFinding
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrAppFinding overwrites any union data inside the EntryMappingRetrieverFindingsInnerDetail as the provided ArrAppFinding
func (t *EntryMappingRetrieverFindingsInnerDetail) FromArrAppFinding(v ArrAppFinding) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrAppFinding performs a merge with any union data inside the EntryMappingRetrieverFindingsInnerDetail, using the provided ArrAppFinding
func (t *EntryMappingRetrieverFindingsInnerDetail) MergeArrAppFinding(v ArrAppFinding) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFolderFinding returns the union data inside the EntryMappingRetrieverFindingsInnerDetail as a FolderFinding
func (t EntryMappingRetrieverFindingsInnerDetail) AsFolderFinding() (FolderFinding, error) {
	var body FolderFinding
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFolderFinding overwrites any union data inside the EntryMappingRetrieverFindingsInnerDetail as the provided FolderFinding
func (t *EntryMappingRetrieverFindingsInnerDetail) FromFolderFinding(v FolderFinding) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFolderFinding performs a merge with any union data inside the EntryMappingRetrieverFindingsInnerDetail, using the provided FolderFinding
func (t *EntryMappingRetrieverFindingsInnerDetail) MergeFolderFinding(v FolderFinding) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EntryMappingRetrieverFindingsInnerDetail) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EntryMappingRetrieverFindingsInnerDetail) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get a list of entry mappings.
	// (GET /entry-mappings)
	GetEntryMappings(w http.ResponseWriter, r *http.Request, params GetEntryMappingsParams)
	// Get a list of retrievers.
	// (GET /retrievers)
	GetRetrievers(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetEntryMappings operation middleware
func (siw *ServerInterfaceWrapper) GetEntryMappings(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEntryMappingsParams

	// ------------- Required query parameter "page" -------------

	if paramValue := r.URL.Query().Get("page"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "page"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Required query parameter "pageSize" -------------

	if paramValue := r.URL.Query().Get("pageSize"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "pageSize"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", r.URL.Query(), &params.Filter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEntryMappings(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRetrievers operation middleware
func (siw *ServerInterfaceWrapper) GetRetrievers(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRetrievers(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/entry-mappings", wrapper.GetEntryMappings)
	m.HandleFunc("GET "+options.BaseURL+"/retrievers", wrapper.GetRetrievers)

	return m
}

type ErrorResponseJSONResponse ErrorResponseBody

type GetEntryMappingsRequestObject struct {
	Params GetEntryMappingsParams
}

type GetEntryMappingsResponseObject interface {
	VisitGetEntryMappingsResponse(w http.ResponseWriter) error
}

type GetEntryMappings200JSONResponse GetEntryMappings200Response

func (response GetEntryMappings200JSONResponse) VisitGetEntryMappingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetEntryMappings4XXJSONResponse struct {
	Body       ErrorResponseBody
	StatusCode int
}

func (response GetEntryMappings4XXJSONResponse) VisitGetEntryMappingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetEntryMappings5XXJSONResponse struct {
	Body       ErrorResponseBody
	StatusCode int
}

func (response GetEntryMappings5XXJSONResponse) VisitGetEntryMappingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetRetrieversRequestObject struct {
}

type GetRetrieversResponseObject interface {
	VisitGetRetrieversResponse(w http.ResponseWriter) error
}

type GetRetrievers200JSONResponse GetRetrievers200Response

func (response GetRetrievers200JSONResponse) VisitGetRetrieversResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetRetrievers4XXJSONResponse struct {
	Body       ErrorResponseBody
	StatusCode int
}

func (response GetRetrievers4XXJSONResponse) VisitGetRetrieversResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetRetrievers5XXJSONResponse struct {
	Body       ErrorResponseBody
	StatusCode int
}

func (response GetRetrievers5XXJSONResponse) VisitGetRetrieversResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Get a list of entry mappings.
	// (GET /entry-mappings)
	GetEntryMappings(ctx context.Context, request GetEntryMappingsRequestObject) (GetEntryMappingsResponseObject, error)
	// Get a list of retrievers.
	// (GET /retrievers)
	GetRetrievers(ctx context.Context, request GetRetrieversRequestObject) (GetRetrieversResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// GetEntryMappings operation middleware
func (sh *strictHandler) GetEntryMappings(w http.ResponseWriter, r *http.Request, params GetEntryMappingsParams) {
	var request GetEntryMappingsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetEntryMappings(ctx, request.(GetEntryMappingsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetEntryMappings")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetEntryMappingsResponseObject); ok {
		if err := validResponse.VisitGetEntryMappingsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetRetrievers operation middleware
func (sh *strictHandler) GetRetrievers(w http.ResponseWriter, r *http.Request) {
	var request GetRetrieversRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetRetrievers(ctx, request.(GetRetrieversRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetRetrievers")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetRetrieversResponseObject); ok {
		if err := validResponse.VisitGetRetrieversResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}
